namespace <%= namespace %> {
    using System;
    using System.Text;
    using System.Collections;
    using System.Collections.Generic;
    using <%= namespace %>.SDK;
    using <%= namespace %>.GraphQL;

    /// <summary>
    /// Is the main entry point for the Unity Buy SDK. Using <see ref="ShopifyBuy.Client" /> you'll
    /// create a client which can create queries on the Storefront API. <see ref="ShopifyClient">ShopifyClient </see>
    /// can also be used to create a <see ref="Cart">Cart </see>.
    /// </summary>
    public class ShopifyBuy {
        /// <summary>
        /// version of the Unity Buy SDK
        /// </summary>
        public const string VERSION = "<%= version %>";

        #if (SHOPIFY_TEST)
        public static void Reset() {
            DefaultClient = null;
            ClientByDomain = new Dictionary<string, ShopifyClient>();
        }
        #endif

        /// <summary>
        /// Will return the default <see ref="ShopifyClient">ShopifyClient </see>. The default client is the first client created after 
        /// calling  <see ref="ShopifyBuy.Init">ShopifyBuy.Init </see>. It should be noted that <see ref="ShopifyBuy.Init">ShopifyBuy.Init </see>
        /// must be called before trying to call this function.
        /// </summary>
        public static ShopifyClient Client() {
            return DefaultClient;
        }

        /// <summary>
        /// Will return a <see ref="ShopifyClient">ShopifyClient </see> for the <c>domain<c> passed in. It should be noted 
        /// that <see ref="ShopifyBuy.Init">ShopifyBuy.Init </see> must be called before trying to call this function.
        /// </summary>
        /// <param name="domain">the domain associated to a client</param>
        public static ShopifyClient Client(string domain) {
            if (ClientByDomain.ContainsKey(domain)) {
                return ClientByDomain[domain];
            } else {
                return null;
            }
        }

        /// <summary>
        /// Will initialize a <see ref="ShopifyClient">ShopifyClient </see> that can be used to query the Storefront API.
        /// The default client which can be accessed by calling <see ref="ShopifyBuy.Client">ShopifyBuy.Client() </see> which is
        /// initialized after <see ref="ShopifyBuy.Init">ShopifyBuy.Init </see> is called. To access the client for the specific
        /// domain passed use <see ref="ShopifyBuy.Client">ShopifyBuy.Client(domain) </see>.
        /// </summary>
        /// <param name="accessToken">access token that was generated for your store</param>
        /// <param name="domain">domain of your Shopify store</param>
        public static ShopifyClient Init(string accessToken, string domain) {
            if (!ClientByDomain.ContainsKey(domain)) {
                ClientByDomain[domain] = new ShopifyClient(accessToken, domain);

                if (DefaultClient == null) {
                    DefaultClient = ClientByDomain[domain];
                }
            }

            return ClientByDomain[domain];
        }

        /// <summary>
        /// Typically not used but it is possible to create a <see ref="ShopifyClient">ShopifyClient </see> by passing an instance
        /// that implements <see ref="ILoader">ILoader </see>. <see ref="ILoader">ILoader's </see> handle network communicationication with
        /// the Storefront API. This functionality is useful if you'd like to use the Unity Buy SDK in a C# environment
        /// outside of Unity. The <c>domain</c> string used to access specific initialized clients is inferred from 
        /// <see ref="ILoader">ILoader.Domain</see> which can be used to request a specific client.
        /// </summary>
        /// <param name="loader">a loader which will handle network communicationication with the Storefront API</param>
        public static ShopifyClient Init(ILoader loader) {
            string domain = loader.Domain;

            if (!ClientByDomain.ContainsKey(domain)) {
                ClientByDomain[domain] = new ShopifyClient(loader);

                if (DefaultClient == null) {
                    DefaultClient = ClientByDomain[domain];
                }
            }

            return ClientByDomain[domain];
        }

        private static ShopifyClient DefaultClient;
        private static Dictionary<string, ShopifyClient> ClientByDomain = new Dictionary<string, ShopifyClient>();
    }

    public delegate void ResponseProductsHandler(List<Product> products, List<string> errors, string httpError);
    public delegate void ResponseCollectionsHandler(List<Collection> collections, List<string> errors, string httpError);
    public delegate void ResponseQueryHandler(<%= schema.query_root_name %> response, List<string> errors, string httpError);
    public delegate void ResponseMutationHandler(<%= schema.mutation_root_name %> response, List<string> errors, string httpError);

    /// <summary>
    /// <see cref="ShopifyClient">ShopifyClient </see> is the entry point to communicate with the Shopify Storefront API.
    /// <see cref="ShopifyClient">ShopifyClient </see> also has functionality to easily generate and send queries to receive
    /// information about products, collections, and has the ability to create checkouts.
    /// </summary>
    public class ShopifyClient {
        /// <summary>
        /// this is a dictionary which defines aliases, <c>maxWidth</c>, and <c>maxHeight</c> for images loaded by
        /// <see ref="ShopifyClient.products">products </see> and <see ref="ShopifyClient.collections">collections </see>.
        /// Basically all Products images, Product variant images, and Collection images will be queried using aliases
        /// defined by this dictionary's keys and the <c>maxWidth</c> and <c>maxHeight</c> will be this dictionary's values.
        ///
        /// \code{.cs}
        /// // returns an image source url whose dimensions are never greater than 100px
        /// string srcSmallImage = productVariant.image("small").src();
        ///
        /// // returns an image source url whose dimensions are never greater than 1024px
        /// string src1024Image = productVariant.image("resolution_1024").src();
        /// \endcode
        /// </summary>
        public static Dictionary<string,int> defaultImageSizes = new Dictionary<string, int>() {
            {"pico", 16},
            {"icon", 32},
            {"thumb", 50},
            {"small", 100},
            {"compact", 160},
            {"medium", 240},
            {"large", 480},
            {"grande", 600},
            {"resolution_1024", 1024},
            {"resolution_2048", 2048}
        };

        /// <summary>
        /// <see ref="ShopifyClient.AccessToken">AccessToken </see> is the access token associated with this client to query Shopify
        /// </summary>
        public string AccessToken {
            get {
                return _AccessToken;
            }
        }

        /// <summary>
        /// <see ref="ShopifyClient.Domain">Domain </see> is the Shopify store domain associated with this client
        /// </summary>
        public string Domain {
            get {
                return _Domain;
            }
        }

        QueryLoader Loader;
        string _AccessToken;
        string _Domain;
        Cart DefaultCart;
        Dictionary<string,Cart> CartsById;

        /// <summary>
        /// <see ref="ShopifyClient">ShopifyClient </see> is the entry point to communicate with the Shopify Storefront API.
        /// <see ref="ShopifyClient">ShopifyClient </see> also has functionality to easily generate and send queries to receive
        /// information about products, collections, and has the ability to create checkouts.
        /// </summary>
        /// <param name="accessToken">the access token used to query the Shopify Storefront API for a store</param>
        /// <param name="domain">domain for the Shopify store</param>
        public ShopifyClient(string accessToken, string domain) {
            _AccessToken = accessToken;
            _Domain = domain;

            #if !SHOPIFY_UNIT_TEST
            Loader = new QueryLoader(new UnityLoader(domain, AccessToken));
            #endif
        }

        /// <summary>
        /// It is possible to instantiate a <see ref="ShopifyClient">ShopifyClient </see> by passing an instance
        /// that implements <see ref="ILoader">ILoader </see>. <see ref="ILoader">ILoader's </see> handle network communication with
        /// the Storefront API. This functionality is useful if you'd like to use the Unity Buy SDK in a C# environment
        /// outside of Unity. The <c>domain</c> string is inferred from <see ref="ILoader">ILoader's </see> which can be used
        /// to request a specific client.
        /// </summary>
        /// <param name="loader">a loader which will handle network communicationication with the Storefront API</param>
        public ShopifyClient(ILoader loader) {
            _AccessToken = loader.AccessToken;
            _Domain = loader.Domain;

            Loader = new QueryLoader(loader);
        }

        /// <summary>
        /// Will generate a query to receive all <c>products</c> from a Shopify store. The generated query will query the following on products:
        ///     - id
        ///     - title
        ///     - descriptionHtml
        ///     - images (with aliases defined by imageResolutions passed in or defaultImageSizes if imageResolutions was not passed)
        ///         - altText
        ///         - src
        ///     - options
        ///         - name
        ///         - values
        ///     - variants
        ///         - id
        ///         - available
        ///         - price
        ///         - title
        ///         - weight
        ///         - weightUnit
        ///         - selectedOptions
        ///             - name
        ///             - values
        ///         - image (with aliases defined by imageResolutions passed in or defaultImageSizes if imageResolutions was not passed)
        ///             - altText
        ///             - src
        ///     - collections
        ///         - image (with aliases defined by imageResolutions passed in or defaultImageSizes if imageResolutions was not passed)
        ///             - altText
        ///             - src
        ///         - title
        ///         - updatedAt
        ///
        /// It should be noted that <c>shop.products</c> is a Connection (GraphQL paginated data structure). <see ref="ShopifyClient.products">products </see>
        /// will load all pages of products by default unless a value is passed for the <c>first</c> param.
        /// </summary>
        /// <param name="callback">callback that will receive responses from server</param>
        /// <param name="first">can be used to limit how many products are returned. For instance 10 would return only 10 products</param>
        /// <param name="after">
        /// this is an advanced feature but when querying Relay Connections a cursor is returned which can be used to determine 
        /// where paginated loading begins. For instance when used with <c>first: 10</c> and <c>after: "abc"</c> only the first 10
        /// products would be loaded after cursor <c>"abc"</c>
        /// </param>
        /// <param name="imageResolutions">
        /// is a dictionary used to set resolutions at which images are queried. This Dictionary effects how Product images, Product Variant image, 
        /// and Collection image is queried. If <c>imageResolutions</c> is omitted then <see ref="ShopifyClient.defaultImageSizes">ShopifyClient.defaultImageSizes </see>
        /// will be used instead.
        ///
        /// This Dictionary's keys refer to an alias and it's values refer to <c>maxWidth</c> and <c>maxHeight</c> for images. So for instance
        /// if you wanted to have images which all had a <c>maxWidth</c> and <c>maxHeight</c> of 200px you'd pass in a dictionary that looks like this:
        /// \code{.cs}
        /// Dictionary<string, int> imageResolutions = new Dictionary<string, int>() { {"res200_by_200", 200} };
        /// \endcode
        /// In the above case to access images for that resolution you'd do the following:
        /// \code{.cs}
        /// string src200x200 = productVariant.image("res200_by_200").src();
        /// \endcode
        /// </param>
        public void products(ResponseProductsHandler callback, int? first = null, string after = null, Dictionary<string,int> imageResolutions = null) {
            if (imageResolutions == null) {
                imageResolutions = defaultImageSizes;
            }

            GetProductsList((products, errors, httpError) => {
                if (httpError != null) {
                    callback(null, null, httpError);
                } else if (errors != null) {
                    callback(null, errors, null);
                } else {
                    List<ConnectionQueryInfo> connectionInfos = new List<ConnectionQueryInfo>() { 
                        new ConnectionQueryInfo(
                            getConnection: (p) => ((Product) p).images(),
                            query: (p, imagesAfter) => {
                                ((ProductQuery) p).images(ic => DefaultQueries.products.ImageConnection(ic),
                                    first: DefaultQueries.MaxPageSize, after: imagesAfter
                                );
                            }
                        ),
                        new ConnectionQueryInfo(
                            getConnection: (p) => ((Product) p).variants(),
                            query: (p, variantsAfter) => {
                                ((ProductQuery) p).variants(vc => DefaultQueries.products.ProductVariantConnection(vc, defaultImageSizes),
                                    first: DefaultQueries.MaxPageSize, after: variantsAfter
                                );
                            }
                        ),
                        new ConnectionQueryInfo(
                            getConnection: (p) => ((Product) p).collections(),
                            query: (p, collectionsAfter) => {
                                ((ProductQuery) p).collections(cc => DefaultQueries.products.CollectionConnection(cc),
                                    first: DefaultQueries.MaxPageSize, after: collectionsAfter
                                );
                            }
                        )
                    };

                    foreach(string alias in imageResolutions.Keys) {
                        connectionInfos.Add(new ConnectionQueryInfo(
                            getConnection: (p) => ((Product) p).images(alias),
                            query: (p, imagesAfter) => {
                                ((ProductQuery) p).images(ic => DefaultQueries.products.ImageConnection(ic),
                                    first: DefaultQueries.MaxPageSize, 
                                    after: imagesAfter, 
                                    maxWidth: imageResolutions[alias],
                                    maxHeight: imageResolutions[alias],
                                    alias: alias
                                );
                            }
                        ));
                    }

                    ConnectionLoader loader = new ConnectionLoader(Loader);
                    List<Node> nodes = products.ConvertAll(p => (Node) p);
                    
                    loader.QueryConnectionsOnNodes(nodes, connectionInfos, BuildProductQueryOnNode, (nodesResult, errorsNode, httpErrorsNode) => {
                        callback(nodesResult.ConvertAll(n => (Product) n), errorsNode, httpErrorsNode);
                    });
                }
            }, imageResolutions: imageResolutions, first: first, after: after);
        }

        /// <summary>
        /// Will generate a query to receive all <c>collections</c> from a Shopify store. The generated query will query the following on collections:
        ///     - id
        ///     - image
        ///         - altText
        ///         - src
        ///     - products
        ///         - id
        ///
        /// It should be noted that <c>shop.collections</c> is a Connection (GraphQL paginated data structure). <see ref="ShopifyClient.collections">collections </see>
        /// will load all pages of collections by default unless a value is passed for the <c>first</c> param.
        /// </summary>
        /// <param name="callback">will receive responses from server</param>
        /// <param name="first">can be used to limit how many products are returned. For instance 10 would return only 10 collections</param>
        /// <param name="after">
        /// this is an advanced feature but when querying Relay Connections a cursor is returned which can be used to determine 
        /// where paginated loading begins. For instance when used with <c>first: 10</c> and <c>after: "abc"</c> only the first 10
        /// products would be loaded after cursor <c>"abc"</c>
        /// </param>
        public void collections(ResponseCollectionsHandler callback, int? first = null, string after = null) {
            GetCollectionsList((collections, errors, httpError) => {
                if (httpError != null) {
                    callback(null, null, httpError);
                } else if (errors != null) {
                    callback(null, errors, null);
                } else {
                    List<ConnectionQueryInfo> connectionInfos = new List<ConnectionQueryInfo>() { 
                        new ConnectionQueryInfo(
                            getConnection: (c) => ((Collection) c).products(),
                            query: (c, productsAfter) => {
                                ((CollectionQuery) c).products(pc => DefaultQueries.collections.ProductConnection(pc),
                                    first: DefaultQueries.MaxPageSize, after: productsAfter
                                );
                            }
                        )
                    };

                    ConnectionLoader loader = new ConnectionLoader(Loader);
                    List<Node> nodes = collections.ConvertAll(p => (Node) p);
                    
                    loader.QueryConnectionsOnNodes(nodes, connectionInfos, BuildCollectionQueryOnNode, (nodesResult, errorsNode, httpErrorsNode) => {
                        callback(nodesResult.ConvertAll(n => (Collection) n), errorsNode, httpErrorsNode);
                    });
                }
            }, first: first, after: after);
        }

        /// <summary>
        /// Allows you to send custom GraphQL queries to the Storefront API. While having utility functions like <see ref="ShopifyClient.products">products </see>
        /// <see ref="ShopifyClient.collections">collections </see> is useful. The Storefront API has more functionality. This method
        /// allows you to access all the extra functionality that the Storefront API provides.
        ///
        /// The following is a small example querying a shop's name:
        /// \code{.cs}
        /// QueryRoot query = new QueryRootQuery();
        /// query.shop(s => s
        ///     .name()
        /// );
        ///
        /// ShopifyBuy.Client().Query(
        ///     query: query,
        ///     callback: (data, errors, httpErrors) => {
        ///         if (httpErrors != null) {
        ///             Debug.Log("There was an error communicating with the Storefront API");
        ///         } else if (errors != null) {
        ///             Debug.Log("The GraphQL query was invalid");
        ///         } else {
        ///             Debug.Log(data.shop().name());
        ///         }
        ///     }
        /// );
        /// \endcode
        /// </summary>
        /// <param name="query">a GraphQL query to be sent to the Storefront API</param>
        /// <param name="callback">callback which will receive a response from the query</param>
        public void Query(<%= schema.query_root_name %>Query query, ResponseQueryHandler callback) {
            Loader.Query(query, (response) => {
                callback(response.data, response.errors, response.HTTPError);
            });
        }
        
        /// <summary>
        /// Allows you to build and send custom GraphQL queries to the Storefront API. While having utility functions like <see ref="ShopifyClient.products">products </see>
        /// <see ref="ShopifyClient.collections">collections </see> is useful. The Storefront API has more functionality. This method
        /// allows you to access all the extra functionality that the Storefront API provides.
        ///
        /// For instance in the following example we will write a query that returns the Shop's name:
        /// \code{.cs}
        /// ShopifyBuy.Client().Query(
        ///     query: q => q
        ///         .shop(s => s
        ///             .name()
        ///         ),
        ///     callback: (data, errors, httpErrors) => {
        ///         if (httpErrors != null) {
        ///             Debug.Log("There was an error communicating with the Storefront API");
        ///         } else if (errors != null) {
        ///             Debug.Log("The GraphQL query was invalid");
        ///         } else {
        ///             Debug.Log(data.shop().name());
        ///         }
        ///     }
        /// );
        /// \endcode
        /// </summary>
        /// <param name="buildQuery">
        /// delegate that will build a query starting at <see ref="<%= schema.query_root_name %>Query"><%= schema.query_root_name %>Query </see>
        /// which will be sent to the Storefront API
        /// </param>
        /// <param name="callback">callback which will receive a response</param>
        public void Query(<%= schema.query_root_name %>Delegate buildQuery, ResponseQueryHandler callback) {
            <%= schema.query_root_name %>Query query = new <%= schema.query_root_name %>Query();

            buildQuery(query);

            Query(query, callback);
        }

        /// <summary>
        /// Allows you to send custom prebuilt GraphQL mutation queries to the Storefront API
        /// </summary>
        /// <param name="query">a query to be sent to the Storefront API</param>
        /// <param name="callback">callback which will receive a response</param>
        public void Mutation(<%= schema.mutation_root_name %>Query query, ResponseMutationHandler callback) {
            Loader.Mutation(query, (response) => {
                callback(response.data, response.errors, response.HTTPError);
            });
        }

        /// <summary>
        /// Allows you to build and send custom GraphQL mutation queries to the Storefront API
        /// </summary>
        /// <param name="buildQuery">delegate that will build a query starting at <see ref="<%= schema.query_root_name %>Query"><%= schema.mutation_root_name %>Query </see></param>
        /// <param name="callback">callback which will receive a response</param>
        public void Mutation(<%= schema.mutation_root_name %>Delegate buildQuery, ResponseMutationHandler callback) {
            <%= schema.mutation_root_name %>Query query = new <%= schema.mutation_root_name %>Query();

            buildQuery(query);

            Mutation(query, callback);
        }

        /// <summary>
        /// Creates a <see ref="Cart">Cart </see> which can be used to manage line items for an order and create a
        /// web checkout link. One <see ref="ShopifyClient">client </see> can have multiple carts so it's
        /// possible to pass in a <c>cartId</c> to reference a specific cart. If no <c>cartId</c> is passed then
        /// a default <see ref="Cart">Cart </see> is used.
        /// </summary>
        /// <param name="cartId">can be optionally passed in. This is useful if your application needs multiple carts</param>
        public Cart Cart(string cartId = null) {
            if (cartId == null) {
                if (DefaultCart == null) {
                    DefaultCart = new Cart(this);
                }

                return DefaultCart;
            } else {
                if (CartsById == null) {
                    CartsById = new Dictionary<string, Cart>();
                }

                if (!CartsById.ContainsKey(cartId)) {
                    CartsById[cartId] = new Cart(this);
                }

                return CartsById[cartId];
            }
        }

        private void BuildProductQueryOnNode(QueryRootQuery query, List<ConnectionQueryInfo> connectionInfosToBuildQuery, string productId, string alias) {
            query.node(n => n
                .onProduct((p) => {
                    p.id();

                    foreach(ConnectionQueryInfo info in connectionInfosToBuildQuery) {
                        info.Query(p, info.After);
                    }
                }),
                id: productId, alias: alias
            );
        }

        private void BuildCollectionQueryOnNode(QueryRootQuery query, List<ConnectionQueryInfo> connectionInfosToBuildQuery, string collectionId, string alias) {
            query.node(n => n
                .onCollection(c => {
                    c.id();

                    foreach(ConnectionQueryInfo info in connectionInfosToBuildQuery) {
                        info.Query(c, info.After);
                    }
                }),
                id: collectionId, alias: alias
            );
        }

        private void GetProductsList(ResponseProductsHandler callback, Dictionary<string,int> imageResolutions, int? first = null, string after = null) {
            ConnectionLoader loader = new ConnectionLoader(Loader);
            int countToLoad = first == null ? int.MaxValue : (int) first;

            loader.QueryConnection(
                (response) => {
                    QueryRootQuery query = null;

                    List<ProductEdge> edges = response != null ? response.data.shop().products().edges() : null;

                    if (edges != null) {
                        countToLoad -= edges.Count;
                    }

                    if (response == null || (countToLoad > 0 && response.data.shop().products().pageInfo().hasNextPage())) {
                        query = new QueryRootQuery();
                        
                        query = new QueryRootQuery();
                        DefaultQueries.products.ShopProducts(
                            query: query, 
                            imageResolutions: imageResolutions,
                            first: countToLoad > DefaultQueries.MaxPageSize ? DefaultQueries.MaxPageSize : countToLoad, 
                            after: edges != null ? edges[edges.Count - 1].cursor() : after
                        );
                    }

                    return query;
                },
                (response) => {
                    return ((QueryRoot) response).shop().products();
                },
                (response) => {
                    if (response.HTTPError != null) {
                        callback(null, null, response.HTTPError);
                    } else if (response.errors != null) {
                        callback(null, response.errors, null);
                    } else {
                        callback((List<Product>) response.data.shop().products(), null, null);
                    }
                }
            );
        }
        
        private void GetCollectionsList(ResponseCollectionsHandler callback, int? first = null, string after = null) {
            ConnectionLoader loader = new ConnectionLoader(Loader);
            int countToLoad = first == null ? int.MaxValue : (int) first;

            loader.QueryConnection(
                (response) => {
                    QueryRootQuery query = null;

                    List<CollectionEdge> edges = response != null ? response.data.shop().collections().edges() : null;

                    if (edges != null) {
                        countToLoad -= edges.Count;
                    }

                    if (response == null || (countToLoad > 0 && response.data.shop().collections().pageInfo().hasNextPage())) {
                        query = new QueryRootQuery();
                        
                        query = new QueryRootQuery();
                        DefaultQueries.collections.ShopCollections(
                            query: query, 
                            first: countToLoad > DefaultQueries.MaxPageSize ? DefaultQueries.MaxPageSize : countToLoad, 
                            after: edges != null ? edges[edges.Count - 1].cursor() : after,
                            imageResolutions: defaultImageSizes
                        );
                    }

                    return query;
                },
                (response) => {
                    return ((QueryRoot) response).shop().collections();
                },
                (response) => {
                    if (response.HTTPError != null) {
                        callback(null, null, response.HTTPError);
                    } else if (response.errors != null) {
                        callback(null, response.errors, null);
                    } else {
                        callback((List<Collection>) response.data.shop().collections(), null, null);
                    }
                }
            );
        }
    }
}
