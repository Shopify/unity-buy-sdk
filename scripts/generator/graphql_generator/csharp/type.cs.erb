<% isRoot = schema.root_name?(type.name) %>
<% isQueryRoot = type.name == schema.query_root_name %>
namespace <%= namespace %> {
    using System;
    using System.Text;
    using System.Collections.Generic;

    <% case type.kind when 'OBJECT', 'INTERFACE', 'UNION' %>
        /* This is a regular object */

        <%# the following will define a delegate for lamdas. Each delegate name will be followed by Delegate. eg. ShopDelegate %>
        public delegate void <%= type.classify_name %>Delegate(<%= type.classify_name %>Query query);

        <%# the following will start defining the class. Each type name will be followed by Query. eg. ShopQuery %>
        public class <%= type.classify_name %>Query {
            private StringBuilder Query;

            <%# create the constuctor %>
            <% if isRoot %>
                public <%= type.classify_name %>Query() {
                    Query = new StringBuilder("<%= "mutation" unless isQueryRoot %>{");
                }
            <% else %>
                public <%= type.classify_name %>Query(StringBuilder query) {
                    Query = query;
                }
            <% end %>

            <%# now create methods to add fields to queries %>
            <% type.fields.each do |field| %>
                public <%= type.classify_name %>Query <%= escape_reserved_word(field.name) %>(<%= get_field_args(field) %>) {
                    Query.Append("<%= field.name %> ");
                
                    <%# now we we want to handle generating arguments %>
                    <% if field.args.any? %>
                        Arguments args = new Arguments();

                        <%# handle adding required args to the args generator %>
                        <% field.required_args.each do |arg| %>
                            args.Add("<%= arg.name %>", <%= escape_reserved_word(arg.name) %>);
                        <% end %>
                        
                        <% field.optional_args.each do |arg| %>
                            if (<%= escape_reserved_word(arg.name) %> != null) {
                                args.Add("<%= arg.name %>", <%= escape_reserved_word(arg.name) %>);
                            }
                        <% end %>

                        Query.Append(args.ToString());
                    <% end %>


                    <%# if this field is an OBJECT we want to be able to query subfields %>
                    <% if field.type.subfields? %>
                        Query.Append("{");
                        addTo(new <%= field.type.unwrap.classify_name %>Query(Query));
                        Query.Append("}");
                    <% end %>

                    return this;
                }
            <% end %>

            <% unless type.object? %>
                <% type.possible_types.each do |possible_type| %>
                    public <%= type.classify_name %>Query on<%= possible_type.classify_name %>(<%= possible_type.classify_name %>Delegate addTo) {
                        Query.Append("...on <%= possible_type.classify_name %>{");
                        addTo(new <%= possible_type.classify_name %>Query(Query));
                        Query.Append("}");
                        return this;
                    }
                <% end %>
            <% end %>

            <%# if this is the root we want to add in a ToString method %>
            <% if isRoot %>
                public override string ToString() {
                    return BuildOptimizedQuery();
                }

                private string BuildOptimizedQuery() {
                    StringBuilder tempQuery = new StringBuilder(Query.ToString());

                    // add in the final closing "}"
                    tempQuery.Append("}");

                    // optimize query by removing extra white space
                    tempQuery.Replace(" (", "(");
                    tempQuery.Replace(" )", ")");
                    tempQuery.Replace(" {", "{");
                    tempQuery.Replace(" }", "}");

                    return tempQuery.ToString();
                }
            <% end %>
        }
    <% when 'INPUT_OBJECT' %>
        /* This is an input object */
        public class <%= type.classify_name %> : InputBase {
            <%# create a constructor for the input type %>
            public <%= type.classify_name %>(<%= get_input_args(type) %>) {
                <%# handle adding required fields %>
                <% type.required_input_fields.each do |field| %>
                    Add("<%= field.name %>", <%= escape_reserved_word(field.name) %>);
                <% end %>
                
                <%# handle adding optional fields %>
                <% type.optional_input_fields.each do |field| %>
                    if (<%= escape_reserved_word(field.name) %> != null) {
                        Add("<%= field.name %>", <%= escape_reserved_word(field.name) %>);
                    }
                <% end %>
            }
        }
    <% when 'ENUM' %>
        public enum <%= type.classify_name %> {
            <%= type.enum_values.map{ |enum| enum.name }.push("UNKNOWN").join(", ") %>
        }
    <% end %>
}
