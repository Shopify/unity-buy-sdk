#if UNITY_IOS
namespace <%= namespace %>.SDK.iOS {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using <%= namespace %>.SDK.iOS;
    using <%= namespace %>.SDK;
    using <%= namespace %>.MiniJSON;

    abstract class iOSNativeCheckout : INativeCheckout, IApplePayEventReceiver {

        protected Cart CurrentCart;

        protected CheckoutSuccessCallback OnSuccess;
        protected CheckoutCancelCallback OnCancelled;
        protected CheckoutFailureCallback OnFailure;

        public iOSNativeCheckout(Cart cart) {
            CurrentCart = cart;
        }

        /// <summary>
        /// Checks if the device is capable of paying with Apple Pay
        /// </summary>
        /// <returns>True if the device is capable of paying with Apple Pay</returns>
        public abstract bool CanCheckout();

        /// <summary>
        /// Checks if the device is capable of setting up Apple Pay
        /// </summary>
        /// <returns>True if the device is capable of setting up Apple Pay </returns>
        public abstract bool CanShowPaymentSetup();

        /// <summary>
        /// Launches the iOS Wallet App, for the user to sign up with Apple Pay
        /// </summary>
        public abstract void ShowPaymentSetup();

        /// <summary>
        /// Starts the process of making a payment through Apple Pay.
        /// </summary>
        /// <remarks>
        ///  Displays a payment interface to the user based on the contents of the Cart
        /// </remarks>
        /// <param name="key">Merchant ID for Apple Pay from the Apple Developer Portal</param>
        /// <param name="success">Delegate method that will be notified upon a successful payment</param>
        /// <param name="failure">Delegate method that will be notified upon a failure during the checkout process</param>
        /// <param name="cancelled">Delegate method that will be notified upon a cancellation during the checkout process</param>
        public abstract void Checkout(string key, CheckoutSuccessCallback success, CheckoutCancelCallback cancelled, CheckoutFailureCallback failure);

        public void UpdateSummaryItemsForShippingIdentifier(string serializedMessage) {
            var message = NativeMessage.CreateFromJSON(serializedMessage);

            CurrentCart.SetShippingLine(message.Content, (ShopifyError error) => {
                if (error == null) {
                    var summaryItems = GetSummaryItems();
                    message.Respond(new ApplePayEventResponse(ApplePayAuthorizationStatus.Success, summaryItems).ToJsonString());
                } else {
                    message.Respond(new ApplePayEventResponse(ApplePayAuthorizationStatus.Failure).ToJsonString());
                }
            });
        }

        public void UpdateSummaryItemsForShippingContact(string serializedMessage) {
            var message = NativeMessage.CreateFromJSON(serializedMessage);
            var contentDictionary = (Dictionary<string, object>)Json.Deserialize(message.Content);
            var mailingAddressInput = new MailingAddressInput(contentDictionary);

            Action respondWithSuccess = () => {
                message.Respond(new ApplePayEventResponse(ApplePayAuthorizationStatus.Success, GetSummaryItems(), GetShippingMethods()).ToJsonString());
            };

            Action<ShopifyError> respondToError = (ShopifyError error) => {
                ApplePayEventResponse response = new ApplePayEventResponse(ApplePayAuthorizationStatus.Failure);

                // Check to see if this is a recoverable user error
                if (error.Type == ShopifyError.ErrorType.UserError) {
                    var userErrors = CurrentCart.UserErrors;
                    var status = GetAuthorizationStatusFromPreliminaryShippingUserErrors(userErrors);

                    if (status == ApplePayAuthorizationStatus.InvalidShippingPostalAddress) {
                        response = new ApplePayEventResponse(status, GetSummaryItems());
                    }
                }

                message.Respond(response.ToJsonString());
            };

            CurrentCart.SetShippingAddress(mailingAddressInput, (ShopifyError error) => {
                if (error == null) {
                    respondWithSuccess();
                } else {
                    respondToError(error);
                }
            });
        }

        public void FetchApplePayCheckoutStatusForToken(string serializedMessage) {
            var checkout = CurrentCart.CurrentCheckout;
            var message = NativeMessage.CreateFromJSON(serializedMessage);
            var amount  = checkout.totalPrice();
            var payment = new ApplePayPayment(message.Content);
            var tokenizedPaymentInput = new TokenizedPaymentInput(amount: amount, billingAddress: payment.BillingAddress, idempotencyKey: payment.TransactionIdentifier, paymentData: payment.PaymentData, type: "apple_pay");

            Action performCheckout = () => {
                CheckoutWithTokenizedPayment(tokenizedPaymentInput, checkout, (ApplePayEventResponse errorResponse) => {
                    if (errorResponse == null) {
                        message.Respond((new ApplePayEventResponse(ApplePayAuthorizationStatus.Success)).ToJsonString());
                    } else {
                        message.Respond(errorResponse.ToJsonString());
                    }
                });
            };

            SetFinalCheckoutFieldsForPayment(payment, checkout, (ApplePayEventResponse errorResponse) => {
                if (errorResponse == null) {
                    performCheckout();
                } else {
                    message.Respond(errorResponse.ToJsonString());
                }
            });
        }

        public void DidFinishCheckoutSession(string serializedMessage) {
            var message = NativeMessage.CreateFromJSON(serializedMessage);
            var paymentStatus = (NativePaymentStatus) Enum.Parse(typeof(NativePaymentStatus), (string) message.Content);
            switch (paymentStatus) {
            case NativePaymentStatus.Success:
                OnSuccess();
                return;
            case NativePaymentStatus.Cancelled:
                OnCancelled();
                return;
            case NativePaymentStatus.Failed:
                var error = new ShopifyError(ShopifyError.ErrorType.NativePaymentProcessingError, "Unable to retrieve a payment from the user's payment provider. Fallback to web checkout.");
                OnFailure(error);
                return;
            }
        }

        protected void StoreCallbacks(CheckoutSuccessCallback success, CheckoutCancelCallback cancelled, CheckoutFailureCallback failure) {
            OnSuccess = success;
            OnCancelled = cancelled;
            OnFailure = failure;
        }

        protected List<SummaryItem> GetSummaryItems() {
            var checkout = CurrentCart.CurrentCheckout;
            var summaryItems = new List<SummaryItem>();
            summaryItems.Add(new SummaryItem("SUBTOTAL", checkout.subtotalPrice().ToString()));

            if (checkout.requiresShipping()) {
                try {
                    summaryItems.Add(new SummaryItem("SHIPPING", checkout.shippingLine().price().ToString()));
                } catch {}
            }

            summaryItems.Add(new SummaryItem("TAXES", checkout.totalTax().ToString()));
            summaryItems.Add(new SummaryItem("TOTAL", checkout.totalPrice().ToString()));

            return summaryItems;
        }

        protected List<ShippingMethod> GetShippingMethods() {
            var checkout = CurrentCart.CurrentCheckout;
            var shippingMethods = new List<ShippingMethod>();

            try {
                var availableShippingRates = checkout.availableShippingRates().shippingRates();

                foreach (var shippingRate in availableShippingRates) {
                    shippingMethods.Add(new ShippingMethod(shippingRate.title(), shippingRate.price().ToString(), shippingRate.handle()));
                }
            } catch (Exception e) {
                throw new Exception("Attempted to gather information on available shipping rates on CurrentCheckout, but CurrentCheckout do not have those properties queried", e);
            }

            return shippingMethods;
        }

        protected delegate void ApplePayEventHandlerCompletion(ApplePayEventResponse errorResponse);

        protected enum NativePaymentStatus {
            Success, Cancelled, Failed
        }

        protected void SetFinalCheckoutFieldsForPayment(ApplePayPayment payment, Checkout checkout, ApplePayEventHandlerCompletion callback) {

            ShippingFields? shippingFields = null;
            if (checkout.requiresShipping()) {
                shippingFields = new ShippingFields(payment.ShippingAddress, payment.ShippingIdentifier);
            }

            CurrentCart.SetFinalCheckoutFields(payment.Email, shippingFields, (ShopifyError error) => {
                if (error == null) {
                    callback(null);
                } else {
                    ApplePayEventResponse response = new ApplePayEventResponse(ApplePayAuthorizationStatus.Failure);

                    // Check to see if this is a recoverable user error
                    if (error.Type == ShopifyError.ErrorType.UserError) {
                        var userErrors = CurrentCart.UserErrors;
                        var status = GetAuthorizationStatusFromShippingUserErrors(userErrors);

                        if (status == ApplePayAuthorizationStatus.InvalidShippingPostalAddress) {
                            response = new ApplePayEventResponse(status, GetSummaryItems());
                        } else if (status == ApplePayAuthorizationStatus.InvalidShippingContact) {
                            response = new ApplePayEventResponse(status, GetSummaryItems(), GetShippingMethods());
                        }
                    }

                    callback(response);
                }
            });
        }

        protected void CheckoutWithTokenizedPayment(TokenizedPaymentInput tokenizedPaymentInput, Checkout checkout, ApplePayEventHandlerCompletion callback) {

            CurrentCart.CheckoutWithTokenizedPayment(tokenizedPaymentInput, (ShopifyError error) => {
                if (error == null) {
                    callback(null);
                } else {
                    ApplePayEventResponse response = new ApplePayEventResponse(ApplePayAuthorizationStatus.Failure);

                    // Check to see if this is a recoverable user error
                    if (error.Type == ShopifyError.ErrorType.UserError) {
                        var userErrors = CurrentCart.UserErrors;
                        var status = GetAuthorizationStatusFromCheckoutUserErrors(userErrors);

                        if (status != ApplePayAuthorizationStatus.Failure) {
                            response = new ApplePayEventResponse(status, GetSummaryItems(), GetShippingMethods());
                        } else {
                            response = new ApplePayEventResponse(status);
                        }
                    }

                    callback(response);
                }
            });
        }

        protected ApplePayAuthorizationStatus GetAuthorizationStatusFromCheckoutUserErrors(List<UserError> errors) {
            // Check to see if any of the user errors are not billing address errors
            // If it is not a billing address error return a failure
            foreach (var error in errors) {
                var fields = error.field();
                var isBillingAddressError = false;

                foreach(var field in fields) {
                    if (field.Equals("billingAddress")) {
                        isBillingAddressError = true;
                        break;
                    }
                }

                if (!isBillingAddressError) {
                    return ApplePayAuthorizationStatus.Failure;
                }
            }

            return ApplePayAuthorizationStatus.InvalidBillingPostalAddress;
        }

        protected ApplePayAuthorizationStatus GetAuthorizationStatusFromShippingUserErrors(List<UserError> errors) {

            string[] shippingAddressFields = {"address1", "address2", "city", "country", "province", "zip"};
            var shippingAddressFieldsSet = new HashSet<string>(shippingAddressFields);

            string[] shippingContactFields = {"firstName", "lastName", "phone", "email"};
            var shippingContactFieldsSet = new HashSet<string>(shippingContactFields);

            ApplePayAuthorizationStatus statusToReturn = ApplePayAuthorizationStatus.Failure;

            foreach (var error in errors) {
                var fields = error.field();
                var lastField = fields[fields.Count - 1];

                var isInvalidShippingAddressError =  shippingAddressFieldsSet.Contains(lastField);
                var isInvalidShippingContactError =  shippingContactFieldsSet.Contains(lastField);

                if (isInvalidShippingAddressError) {
                    statusToReturn = ApplePayAuthorizationStatus.InvalidShippingPostalAddress;
                } else if (isInvalidShippingContactError) {
                    statusToReturn = ApplePayAuthorizationStatus.InvalidShippingContact;
                } else {
                    statusToReturn = ApplePayAuthorizationStatus.Failure;
                    break;
                }
            }

            return statusToReturn;
        }

        // We only receive a partial shipping address before the user has authenticated
        // City, State, Zip, Country
        // So we will receive user errors from our GraphQL query, even though it was a success
        protected ApplePayAuthorizationStatus GetAuthorizationStatusFromPreliminaryShippingUserErrors(List<UserError> errors) {

            string[] shippingAddressFields = {"city", "country", "province", "zip"};
            var shippingAddressFieldsSet = new HashSet<string>(shippingAddressFields);

            foreach (var error in errors) {
                var fields = error.field();
                var lastField = fields[fields.Count - 1];
                var isInvalidShippingAddressError = shippingAddressFieldsSet.Contains(lastField);

                if (!isInvalidShippingAddressError) {
                    return ApplePayAuthorizationStatus.Failure;
                }
            }

            return ApplePayAuthorizationStatus.InvalidShippingPostalAddress;
        }
    }
}
#endif
