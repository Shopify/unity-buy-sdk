namespace <%= namespace %>.SDK {
    using System;
    using System.Text;
    using System.Reflection;
    using System.Collections;
    using System.Collections.Generic;

    public class ShopifyBuy {
        public static ShopifyClient Client() {
            return DefaultClient;
        }

        public static ShopifyClient Client(string domain) {
            if (ClientByDomain.ContainsKey(domain)) {
                return ClientByDomain[domain];
            } else {
                return null;
            }
        }

        public static ShopifyClient Init(string apiKey, string domain) {
            ClientByDomain[domain] = new ShopifyClient(apiKey, domain);

            if (DefaultClient == null) {
                DefaultClient = ClientByDomain[domain];
            }

            return ClientByDomain[domain];
        }

        public static ShopifyClient Init(ILoader loader, string domain = null) {
            if (domain != null) {
                ClientByDomain[domain] = new ShopifyClient(loader);

                if (DefaultClient == null) {
                    DefaultClient = ClientByDomain[domain];
                }

                return ClientByDomain[domain];
            } else {
                DefaultClient = new ShopifyClient(loader);

                return DefaultClient;
            }
        }

        private static ShopifyClient DefaultClient;
        private static Dictionary<string, ShopifyClient> ClientByDomain = new Dictionary<string, ShopifyClient>();
    }

    public delegate void ResponseProductsHandler(List<Product> products);
    public delegate void QueryProductHandler(ProductQuery product, string after);
    public delegate void QueryProductMergeHandler(Product product, Product productResult);

    public class ShopifyClient {
        QueryLoader Loader;

        public ShopifyClient(string apiKey, string domain) {
            #if UNITY_EDITOR
            Loader = new QueryLoader(new UnitLoader(domain, Base64(apiKey)));
            #endif
        }

        public ShopifyClient(ILoader loader) {
            Loader = new QueryLoader(loader);
        }

        public void products(ResponseProductsHandler callback, int? first = null, string after = null) {
            GetProductsList((products) => {
                GetConnectionsForProducts(products, callback);
            }, first: first, after: after);
        }

        private string GetAfter(ConnectionInfo info, object connection) {
            string after = null;
            
            MethodInfo pageInfoMethod = info.ConnectionType.GetMethod("pageInfo");
            PageInfo pageInfo = (PageInfo) pageInfoMethod.Invoke(connection, null);

            MethodInfo edgesMethod = info.ConnectionType.GetMethod("edges");
            MethodInfo cursorMethod = info.EdgeType.GetMethod("cursor");

            if (pageInfo.hasNextPage()) {
                IList edges = edgesMethod.Invoke(connection, null) as IList;
                after = (string) cursorMethod.Invoke(edges[edges.Count - 1], null);
            }
        
            return after;
        }

        private object GetConnectionForProduct(ConnectionInfo info, Product product) {
            MethodInfo methodConnection = product.GetType().GetMethod(info.Name);

            return methodConnection.Invoke(product, new object[] { null });
        }

        private struct ConnectionInfo {
            public ConnectionInfo(string name, Type connectionType, Type edgeType, QueryProductHandler query, QueryProductMergeHandler merge) {
                Name = name;
                ConnectionType = connectionType;
                EdgeType = edgeType;
                QueryHandler = query;
                QueryMergeHandler = merge;
            }

            public string Name;
            public Type ConnectionType;
            public Type EdgeType;
            public QueryProductHandler QueryHandler;
            public QueryProductMergeHandler QueryMergeHandler;
        }

        private void GetConnectionsForProducts(List<Product> products, ResponseProductsHandler callback) {
            List<ConnectionInfo> connections = new List<ConnectionInfo>() { 
                new ConnectionInfo(
                    name: "images", 
                    connectionType: typeof(ImageConnection), 
                    edgeType: typeof(ImageEdge), 
                    query: (p, after) => {
                        p.images(ic => ic
                            .edges(ie => ie
                                .node(ien => ien
                                    .altText()
                                    .src()
                                )
                                .cursor()
                            )
                            .pageInfo(pi => pi
                                .hasNextPage()
                            ),
                            first: 250, after: after
                        );
                    },
                    merge: (p, pr) => {
                        p.images().AddFromConnection(pr.images());
                    }
                ),
                new ConnectionInfo(
                    name: "variants", 
                    connectionType: typeof(ProductVariantConnection), 
                    edgeType: typeof(ProductVariantEdge), 
                    query: (p, after) => {
                        p.variants(vc => vc
                            .edges(ve => ve
                                .node(vn => vn
                                    .available()
                                    .images(pnvi => pnvi
                                        .altText()
                                        .src()
                                    )
                                    .price()
                                    .title()
                                    .weight()
                                    .weightUnit()
                                )
                                .cursor()
                            )
                            .pageInfo(pi => pi
                                .hasNextPage()
                            ),
                            first: 250, after: after
                        );
                    },
                    merge: (p, pr) => {
                        p.variants().AddFromConnection(pr.variants());
                    }
                )
            };

            List<int> productsQueried = new List<int>();
            List<List<ConnectionInfo>> connectionInfoQueried = new List<List<ConnectionInfo>>();
            QueryRootQuery query = new QueryRootQuery();

            for(int i = 0; i < products.Count; i++) {
                Product product = products[i];
                List<string> afters = new List<string>();
                List<ConnectionInfo> connectionInfoForProduct = new List<ConnectionInfo>();
                
                foreach(ConnectionInfo info in connections) {
                    object connection = GetConnectionForProduct(info, product);
                    string after = GetAfter(info, connection);

                    if (after != null) {
                        afters.Add(after);
                        connectionInfoForProduct.Add(info);
                    }
                }

                if (connectionInfoForProduct.Count > 0) {
                    productsQueried.Add(i);
                    connectionInfoQueried.Add(connectionInfoForProduct);

                    query.node(n => n
                    .onProduct((p) => {
                            p.id();

                            for(int j = 0; j < afters.Count; j++) {
                                string after = afters[j];
                                ConnectionInfo info = connectionInfoForProduct[j];
                                
                                info.QueryHandler(p, after);
                            }
                        }),
                        id: product.id(), alias: String.Format("product{0}", i)
                    );
                }
            }

            if (productsQueried.Count == 0) {
                callback(products);
            } else {
                Loader.Query(query, (respone) => {
                    for(int i = 0; i < productsQueried.Count; i++) {
                        int idxQueried = productsQueried[i];
                        List<ConnectionInfo> infos = connectionInfoQueried[i];
                        Product product = products[idxQueried];
                        Product productResult = (Product) respone.data.node(String.Format("product{0}", idxQueried));

                        foreach(ConnectionInfo info in infos) {
                            info.QueryMergeHandler(product, productResult);
                        }
                    }

                    GetConnectionsForProducts(products, callback);
                });
            }
        }

        private void GetProductsList(ResponseProductsHandler callback, int? first = null, string after = null) {
            ConnectionLoader loader = new ConnectionLoader(Loader);
            int countToLoad = first == null ? int.MaxValue : (int) first;

            loader.Query(
                (response) => {
                    QueryRootQuery query = null;
                    List<ProductEdge> edges = response != null ? response.data.shop().products().edges() : null;

                    if (edges != null) {
                        countToLoad -= edges.Count;
                    }

                    if (response == null || (countToLoad > 0 && response.data.shop().products().pageInfo().hasNextPage())) {
                        query = new QueryRootQuery();
                        
                        query = new QueryRootQuery();
                        query.shop(s => s
                            .products(pc => pc
                                .edges(e => e
                                    .node(p => p
                                        .id()
                                        .title()
                                        .bodyHtml()
                                        .images(ic => ic
                                            .edges(ie => ie
                                                .node(imn => imn
                                                    .altText()
                                                    .src()
                                                )
                                                .cursor()
                                            )
                                            .pageInfo(pi => pi
                                                .hasNextPage()
                                            ),
                                            first: 250
                                        )
                                        .options(pn => pn
                                            .name()
                                            .values()
                                        )
                                        .variants(pvc => pvc
                                            .edges(pve => pve
                                                .node(pnv => pnv
                                                    .available()
                                                    .images(pnvi => pnvi
                                                        .altText()
                                                        .src()
                                                    )
                                                    .price()
                                                    .title()
                                                    .weight()
                                                    .weightUnit()
                                                )
                                                .cursor()
                                            )
                                            .pageInfo(pvp => pvp
                                                .hasNextPage()
                                            ),
                                            first: 250
                                        )
                                    )
                                    .cursor()
                                )
                                .pageInfo(pi => pi
                                    .hasNextPage()
                                ),
                                first: countToLoad > 250 ? 250 : countToLoad, after: edges != null ? edges[edges.Count - 1].cursor() : after
                            )
                        );
                    }

                    return query;
                },
                (responses) => {
                    QueryResponse firstResponse = responses[0];

                    foreach(QueryResponse response in responses) {
                        if (response != firstResponse) {
                            firstResponse.data.shop().products().AddFromConnection(
                                response.data.shop().products()
                            );
                        }
                    }

                    return firstResponse;
                },
                (response) => {
                    callback((List<Product>) response.data.shop().products());
                }
            );
        }

        private string Base64(string apiKey) {
            return Convert.ToBase64String(Encoding.UTF8.GetBytes(apiKey));
        }
    }
}
